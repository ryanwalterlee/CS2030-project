package cs2030.simulator;

import java.util.ArrayList;
import java.util.PriorityQueue;
import java.util.function.Supplier;

/**
 * Simulator class that simulates the sequence of events as customers arrive, waits,
 * gets served, leaves and servers resting. 
 */
public class Simulator {

    /**
     * This method is used when the arrival times, serving times,
     * resting times are known beforehand
     * 
     * @param listOfArrivalTimes A List of all arrival times of the customers
     * @param listOfServingTimes A List of all corresponding customer's serving time
     * @param listOfRestTimes A List of rest times that servers take after serving a customer,
     * 1st rest time corresponds to server that finished serving the first customer ever served
     * and so on
     * @param maxQueueLength Maximum queue length that any of the servers can have
     * @param numHumanServers Number of Human Servers
     * @param numSelfCheckout Number of Self Checkout Counters
     * 
     * @return prints out order of events and their times
     */
    public void simulate(ArrayList<Double> listOfArrivalTimes,
        ArrayList<Double> listOfServingTimes,
        ArrayList<Double> listOfRestTimes,
        int maxQueueLength,
        int numHumanServers,
        int numSelfCheckout) {

        // create new array of HumanServers and SelfCheckout
        int totalNumServers = numHumanServers + numSelfCheckout;
        Server[] servers = new Server[totalNumServers];
        for (int i = 0; i < numHumanServers; i++) {
            servers[i] = new HumanServer(i + 1, maxQueueLength);
        }
        for (int i = numHumanServers; i < totalNumServers; i++) {
            servers[i] = new SelfCheckout(i + 1, maxQueueLength);
        }

        // create priority queue for events
        NormalEventComparator eventComparator = new NormalEventComparator();
        PriorityQueue<NormalEvent> pq = new PriorityQueue<NormalEvent>(eventComparator);        
        int customerIdentifier = 1;

        // add arrival events to priority queue
        for (int i = 0; i < listOfArrivalTimes.size(); i++) {
            Customer customer = new Customer(customerIdentifier++, 
                listOfServingTimes.get(i), 
                listOfArrivalTimes.get(i));
            NormalEvent arriveEvent = new NormalEvent("Arrive", 
                customer, 
                listOfArrivalTimes.get(i));
            pq.add(arriveEvent);
        }

        // create new Stats object to track statistics
        Stats stats = new Stats();

        // run through all events in order
        while (!pq.isEmpty()) {
            
            NormalEvent nextEvent = pq.poll();
            nextEvent.execute(pq, servers, listOfRestTimes, stats);
        }

        // print stats
        stats.printStats();
    }

    /**
     * This simulate method is used when arrival time, serving time and resting time is not
     * known before hand and is generated by a RandomGenerator Object
     * 
     * @param seed denotes base seed for the RandomGenerator Object
     * @param numServers represents number of Human Servers
     * @param numSelfCheckout represents number of self checkout counters
     * @param maxQueueLength maximum queue length of all queues
     * @param numCustomers number of customers which corresponds to number of initial arrival events
     * @param arrivalRate parameter for RandomGenerator Object for arrival time
     * @param serviceRate parameter for RandomGenerator Object for serving time
     * @param restingRate parameter for RandomGenerator Object for resting time
     * @param restingProbability probability of a server resting after each customer
     * @param greedyProbability probability of each customer being a greedy customer,
     * greedy customers always pick the shortest queue to queue in
     * 
     * @return prints out order of events and their times
     */
    public void simulate(int seed,
        int numServers,
        int numSelfCheckout,
        int maxQueueLength,
        int numCustomers,
        double arrivalRate,
        double serviceRate,
        double restingRate,
        double restingProbability,
        double greedyProbability) {

        // // create new array of HumanServers and SelfCheckout
        Server[] servers = new Server[numServers + numSelfCheckout];
        for (int i = 0; i < numServers; i++) {
            servers[i] = new HumanServer(i + 1, maxQueueLength);
        }
        for (int i = numServers; i < numSelfCheckout + numServers; i++) {
            servers[i] = new SelfCheckout(i + 1, maxQueueLength);
        }

        // create random generator
        RandomGenerator rng = new RandomGenerator(seed, arrivalRate, serviceRate, restingRate);

        // create priority queue for events
        RandomEventComparator eventComparator = new RandomEventComparator();
        PriorityQueue<RandomEvent> pq = new PriorityQueue<RandomEvent>(eventComparator);        
        int customerIdentifier = 1;

        // add arrival events to priority queue
        double currTime = 0;
        for (int i = 0; i < numCustomers; i++) {

            double interArrivalTime = 0;
            if (i > 0) {
                interArrivalTime = rng.genInterArrivalTime();
            }
            
            // create service time supplier
            Supplier<Double> supplier = () -> rng.genServiceTime();

            // determine if customer is greedy
            double greedyChance = rng.genCustomerType();
            boolean isGreedy = greedyChance < greedyProbability;
            
            Customer customer = new Customer(customerIdentifier++, 
                supplier, 
                currTime + interArrivalTime, 
                isGreedy);

            RandomEvent arriveEvent = new RandomEvent("Arrive", 
                customer, 
                servers[0], 
                currTime + interArrivalTime);

            pq.add(arriveEvent);

            currTime += interArrivalTime;
        }

        // create new Stats object to track statistics
        Stats stats = new Stats();

        // run through all events in order
        while (!pq.isEmpty()) {
            
            RandomEvent nextEvent = pq.poll();
            nextEvent.execute(pq, servers, stats, rng, restingProbability);
        }

        // print stats
        stats.printStats();

    }
}
